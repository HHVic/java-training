# 描述一下什么是Java运行时数据区

## 堆

Java堆是JVM启动时创建的一片**线程共享**的内存区域，也是垃圾回收的主要内存区域，主要存储的是对象、数组和运行时常量

## 虚拟机栈

虚拟机栈是**线程独享**的一片内存区域，主要存储局部变量。每次方法调用都会生成一个栈帧，该栈帧主要存储局部变量表、操作数栈、动态链接、方法出口等信息。每当方法执行完毕之后，该栈帧就会被弹出，栈帧中存储的局部变量将全部失效。

## 本地方法栈

本地方法栈和虚拟机栈一样也是**线程独享**的内存区域，不同的是本地方法栈主要是native方法，这些方法的实现一般都是在JVM虚拟机中

## 方法区

方法区也是一个**线程共享**的内存区域，方法区是JVM规范提出的一种逻辑概念，相应的实现有永久带和元空间，JDK1.8之前被叫做永久带，在JDK1.6的时候永久带主要存储类的信息、运行时常量池、静态变量和JIT编译之后的代码，而到JDK1.7把运行时常量池和静态变量移到堆中存储，此时永久带都是在JVM的内存区域，受JVM的限制。JDK1.8把永久带改名为元空间，实现也是物理内存，不受JVM内存大小的影响。

## 运行时常量池

运行时常量池理论上时方法区的一部分，其中一个class对象有一个运行时常量池，主要包含字面量和符号引用

其中符号引用包含了类的全限定名称、字段的名称和描述符、方法的名称和描述符。

字符串常量池主要用于存储字符串，通过stringTable进行实现，类似于Hash表，主要由数组加链表实现

## 程序计数器

程序计数器是**线程独享**的内存区域，用于指示下一条将要被执行的字节码指令的位置

## 直接内存（堆外内存）

直接内存并不是运行时数据区的一部分，**堆外内存不受垃圾回收机制管理，使用之后必须要手动回收**。

堆外内存分配内存空间的效率不如堆内存，但是在IO的读写性能上远远高于堆内存。所以Java NIO使用了堆外内存

# 堆内存为什么要分为年轻代和老年代

学者研究发现：

1. 大多数对象都是朝生熄灭的
2. 熬过很多次垃圾回收的对象越不容易被回收

基于以上两个现象，提出了分代收集。

1. 如果一个区域的对象大多都是朝生熄灭，把他们集中起来，也就是放到年轻代，每次垃圾回收把那些能存活下来的少量对象留下来，**就能以较低的代价回收到大量的内存空间**。也就是这个原因年轻代一般使用标记复制算法收集垃圾
2. 如果是难以回收的对象，把他们聚集在一起，**就能以较低的频率回收这个区域**。所以老年代一般使用标记整理或者标记清除算法回收垃圾

# 类加载过程

1. 加载：将不同来源的class字节码对象的二进制数据读到内存，将其放到方法区创建一个Class对象
2. 链接：(1) 验证：校验类的正确性是否会损害jvm (2) 准备：为静态变量分配内存，并设置默认值，static final 修饰的基本类型或者String将会被直接赋值 (3) 解析：符号引用转成直接引用
3. 初始化：执行类构造器<clinit>()方法

# Java对象的生命周期

1. class常量池检查该对象对应的类是否已经被加载，如果没有被加载需要先加载类
2. 内存分配：(1) 指针碰撞: 堆内存连续 (2) 空闲列表: 堆内存离散 

内存分配需要解决并发安全：(1) CAS + 重试 (2) TLAB

1. 初始化零值
2. 设置对象头
3. 调用构造方法
4. 使用对象
5. 回收对象

## 完整GC流程

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/22451222/1695654512478-60cb243c-5cab-4292-b405-9bf86f5907cf.jpeg)

## 对象怎么才会进入老年代

1. 对象年龄太大：对象年龄超过进入老年代的阈值
2. 大年龄对象占用空间较大：Minor GC之后，S区对象的总大小大于S区大小的50%，会将最大年龄对象移入到老年代
3. 大对象直接进入老年代：-XX:PretenureSizeThreshold 默认值1M
4. Minor GC之后对象放不进去S区 （内存担保）

## 内存担保机制

在发生Minor GC之前，虚拟机会检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间。**

如果大于则说明Minor GC是安全的

如果小于则虚拟机会继续检查**老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**

如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；

如果小于则改为进行一次Full GC

# 对象内存布局

## 对象头

主要存放对象的元数据信息，比如有**标记字段Mark Word、类型指针KlassPoint和数组长度**（数组对象才有）

1. Mark Word：存储对象标记信息包含锁状态、GC标记
2. KlassPoint：对象所属类的元数据信息，包含类的类型、方法和字段

## 实例数据

主要存放对象的成员变量

## 对其填充

虚拟机规定对象的起始位置是8byte的倍数，如果对象头+实例数据不够则由对其填充补充

# 描述垃圾收集算法和垃圾收集器，以及各有什么特点

## 垃圾收集算法

1. 标记-清除：**效率不高，会有内存碎片**，主要用于老年代
2. 标记-整理: **效率不如标记清除，没有内存碎片**，主要用于老年代
3. 标记-复制：**效率很高，但是需要额外空间**，主要用于年轻代

## 垃圾收集器

常见的垃圾收集器有以下几种：

1. 串行垃圾收集器：Serial GC(年轻代)、Serial Old(老年代)
2. 并行垃圾收集器：Parallel Scavenge(年轻代 吞吐量优先)、Parallel New(年轻代)、Parallel Old(老年代)
3. 并发标记扫描垃圾收集器：CMS
4. 整堆垃圾收集器：G1、ZGC

### 串行垃圾收集器

单线程，**减少不必要的线程上下文切换**，Serial GC使用**标记-复制**算法，Serial Old使用**标记-整理**算法

### 并行垃圾收集器

#### Parallel Scavenge

多线程并发执行，使用**标记-复制**算法，**吞吐量优先**

#### Parallel New

Serial GC 的多线程版本，使用**标记-复制**算法

#### Parallel Old

Parallel New的老年代收集器，使用**标记-整理**算法

### 并发标记扫描垃圾收集器

#### CMS

老年代收集器，**关注停顿时间**，使用**标记-清除**算法，**产生内存碎片**

步骤：

1. 初始标记：标记所有GCRoot关联的对象，会STW
2. 并发标记：和用户线程一起并发标记，所有的可达对象，不会STW
3. 重新标记：对并发标记中用户线程运行产生的垃圾对象中有变动的对象进行重新标记，会STW
4. 并发清理：和用户线程并发执行，清理线程，不会STW

### 整堆收集器

#### G1

属于CMS的升级版，解决了产生内存碎片的问题

优势：

1. 并发回收：利用多核CPU的优势
2. 分代收集：G1可以回收整堆，既可以回收年轻代也可以回收老年代
3. 空间整合：整堆使用**标记-整理**算法，局部使用**标记-复制**算法不会存在内存碎片。
4. 可预测的停顿

#### ZGC